<!DOCTYPE html> <html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">      <title>ChangeMachine</title>   <style>     body {       font-size: 16px;       line-height: 24px;       background: #fff url("bg.png");       color: #252519;       font-family: "Palatino Linotype", "Book Antiqua", Palatino, FreeSerif, serif;       padding: 0 0 50px 50px;     }     div.container {       width: 720px;       margin: 50px 0 50px 50px;     }     p {       width: 550px;     }       #documentation p {         margin-bottom: 4px;       }     a, a:visited {       padding: 0 2px;       text-decoration: none;       background: #dbe6f3;       color: #3f6fa5;     }     a:active, a:hover {       color: #dbe6f3;       background: #3f6fa5;     }     h1, h2, h3, h4, h5, h6 {       margin-top: 40px;       width: 550px;       line-height: 1.25em;     }     b.header {       font-size: 18px;     }     span.alias {       font-size: 14px;       font-style: italic;       margin-left: 20px;     }     table, tr, td {       margin: 0; padding: 0;     }       td {         padding: 2px 12px 2px 0;       }     ul {       list-style-type: circle;       padding: 0 0 0 20px;     }       li {         width: 500px;         margin-bottom: 10px;       }     code, pre, tt {       font-family: Monaco, Consolas, "Lucida Console", monospace;       font-size: 12px;       line-height: 18px;       color: #555529;     }       pre {         font-size: 12px;         padding: 2px 0 2px 12px;         border-left: 6px solid #aaaa99;         margin: 0px 0 30px;       }   </style> </head> <body>   <h1>ChangeMachine</h1>        <em>The quickie-wiki Github project page generator</em>         <p><img src="https://github.com/steelmesh/changemachine/raw/master/assets/changemachine-logo.png" style="float: left" title="ChangeMachine" /></p>

<p>ChangeMachine is a critical component in the <a href="http://github.com/steelmesh">Steelmesh stack</a>.  It is responsible for monitoring and responding to changes in a number of couchdb instances and taking appropriate actions in response to those changes.</p>

<p>The implementation of ChangeMachine is reasonably simple thanks to the <a href="https://github.com/flatiron/neuron">flatiron neuron</a> queueing library and through leveraging <a href="https://github.com/steelmesh/changemate">changemate</a> notifiers. </p>

<p><a href="http://travis-ci.org/#!/steelmesh/changemachine"><img src="https://secure.travis-ci.org/steelmesh/changemachine.png" alt="Build Status"></a></p>

<h2>Design Goals</h2>

<p>ChangeMachine is designed to work in similar fashion to real world </p>

<h2>Examples</h2>

<p>The following code snippets are taken from the examples in the repository:</p>

<h3>Simple Example using Changemate Notifier</h3>

<p>This simple example demonstrates responding to changes from an external couchdb:</p>

<pre>
var cm = require('changemachine'),
    machine = new cm.Machine('<:couch:> http://sidelab.iriscouch.com/seattle_neighbourhood', {
        concurrency: 25 // override neurons default concurrency of 50
    });

machine.on('enter', function(item) {
    console.log('   entered: ' + item.id, machine.stats());
});

// perform actions for each of the 
machine.on('process', function(item) {
    console.log('processing: ' + item.id, machine.stats());

    setTimeout(function() {
        item.done();
        console.log('      done: ' + item.id, machine.stats());
    }, Math.random() * 5000);
});
</pre>

<p>If it is all working nicely, you should see output similar to <a href="https://github.com/steelmesh/changemachine/blob/master/examples/simple.output.txt">this</a>.</p>

<h3>Simple Example demonstrating <code>ready</code> queue</h3>

<p>In the example above, items existed in either the <code>waiting</code> or <code>processing</code> queues.  This because the machine had a <code>process</code> event that could be used to process the items as they enter the machine.  In a case where a <code>process</code> event handler is not defined, however, the items ready for processing (according to neuron's concurrency setting) will be placed in the <code>ready</code> queue.</p>

<p>Let's modify the previous example to wire up the process event after 5 seconds:</p>

<pre>
var cm = require('changemachine'),
    machine = new cm.Machine('<:couch:> http://sidelab.iriscouch.com/seattle_neighbourhood', {
        concurrency: 25 // override neurons default concurrency of 50
    });

machine.on('enter', function(item) {
    console.log('   entered: ' + item.id, machine.stats());
});

setTimeout(function() {
    // perform actions for each of the 
    machine.on('process', function(item) {
        console.log('processing: ' + item.id, machine.stats());

        setTimeout(function() {
            item.done();
            console.log('      done: ' + item.id, machine.stats());
        }, Math.random() * 5000);
    });
}, 5000);
</pre>

<p>In the <a href="https://github.com/steelmesh/changemachine/blob/master/examples/delayedprocess.output.txt">output</a> for this example, you should see that before processing starts a number of items are reported in the <code>ready</code> queue.  Once the <code>process</code> event is connected however, the items move directly from a <code>waiting</code> status to <code>processing</code>.</p>

<h3>State Storage</h3>

<p>At this stage ChangeMachine implements very simple state storage, but it works nicely and event attempts to synchronously persist data when the process <code>exit</code> event is detected.</p>

<p>Below is an example that demonstrates how a state store is configured:</p>

<pre>
var cm = require('changemachine'),
    path = require('path'),
    machine = new cm.Machine('<:couch:> http://sidelab.iriscouch.com/seattle_neighbourhood', {
        stateStore: new cm.JsonStore({ filename: path.resolve(__dirname, 'state.json') })
    }),
    counter = 0;

// perform actions for each of the 
machine.on('process', function(item) {
    console.log('processing item sequence: ' + item.seq);

    counter++;
    item.done();

    // if we have processed 10 items, then stop
    if (counter >= 10) {
        machine.notifier.close();
    }
});
</pre>

<h3>Serializing Data from CouchDB</h3>

<p>If you wanted to extract all the JSON data from documents in a couch database (not the attachments though - although it could be combined with <a href="https://github.com/steelmesh/attachmate">attachmate</a> to achieve that) the following example is probably of interest:</p>

<pre>
var cm = require('changemachine'),
    fs = require('fs'),
    path = require('path'),
    machine = new cm.Machine('<:couch:> http://sidelab.iriscouch.com/seattle_neighbourhood', {
        include_docs: true,
        concurrency: 10 // override neurons default concurrency of 50
    }),
    dataPath = path.resolve(__dirname, 'data');

// perform actions for each of the 
console.log('waiting for change information');
machine.on('process', function(item) {
    try {
        var text = JSON.stringify(item.doc);

        fs.writeFile(path.join(dataPath, item.id + '.json'), text, 'utf8', function(err) {
            if (err) {
                item.fail(err);
            }
            else {
                item.done();
            }

            console.log('wrote ' + item.id + '.json', machine.stats());
        });
    }
    catch (e) {
        console.log('failed writing: ' + item.id, e);
        item.fail(e);
    }
});
</pre>

<h3>Non Notifier Change Machines</h3>

<p>While ChangeMachine is designed to work in conjuction with <a href="https://github.com/steelmesh/changemate">changemate</a>, it is possible to create items and process them manually also.</p>

<pre>
To be completed
</pre>

<h3>Machine Chaining</h3>

<pre>
To be completed
</pre>

<h2>System Internals</h2>

<ul>
<li><p>Attempts to act intelligently when a machine does not have a <code>process</code> event handler.  In this case, items are queued in the <code>ready</code> state and we make use of the <a href="http://nodejs.org/docs/latest/api/events.html#event_newListener">newListener</a> node event to wait for a process event to be connected.  At this stage, similar action is not taken if the process listener is removed.</p></li>
<li><p>Makes use of changemate notifier <code>pause</code> and <code>resume</code> methods to ensure efficient operation even in the case of a massive <code>_changes</code> feed from couch, etc.  In the case that a notifier does not support these operations, items will be queued.</p></li>
</ul>

<h3>On ChangeMate vs Follow</h3>

<p>While at the present stage an implementation of ChangeMachine would have been possible with the excellent <a href="https://github.com/iriscouch/follow">follow</a> library the long term plan is to support monitoring changes from the filesystem and other sources so work changemate has been integrated instead.</p>

<h2>Alternative Systems</h2>

<p>Some alternative systems that do similar things are:</p>

<ul>
<li><p><a href="https://github.com/pgte/banzai">banzai</a> - Banzai looks like an excellent system for processing documents through a number of various states.  Banzai's implementation has definitely influenced parts of ChangeMachine.</p></li>
<li><p><a href="http://hook.io/">hook.io</a> - If you are building, loosely-coupled, distributed systems then hook.io is one of the best choices in the #nodejs space.  There are instances where ChangeMachine could perform a similar function to hook, but in most cases ChangeMachine is designed for simpler scenarios.</p></li>
<li><p><a href="https://github.com/Learnboost/kue">kue</a> - Job processor built around redis, has a pretty admin panel to boot.</p></li>
</ul>

<p>Additionally, as previously stated, ChangeMachine does not attempt to compete with full-blown messaging and queuing systems and if you require a more distributed system then be sure to check out the likes of RabbitMQ and 0MQ.</p> </body> </html>